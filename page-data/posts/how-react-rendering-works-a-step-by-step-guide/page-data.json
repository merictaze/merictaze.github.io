{"componentChunkName":"component---src-templates-post-template-jsx","path":"/posts/how-react-rendering-works-a-step-by-step-guide/","result":{"data":{"site":{"siteMetadata":{"title":"Full Stack Software Development - MericTaze.com","subtitle":"","copyright":"© All rights reserved.","author":{"name":"Meric Taze","twitter":"#"},"disqusShortname":"","url":"https://merictaze.com"}},"markdownRemark":{"id":"8e44eb91-63f5-5213-8607-1c8f84869d30","html":"<p>Although what react is doing looks quite complex, the underlying logic is very simple. And the easiest way to understand is just running some simple examples. We’ll dive into how react renders components and updates the actual DOM.</p>\n<h2 id=\"rendering-react-components\" style=\"position:relative;\"><a href=\"#rendering-react-components\" aria-label=\"rendering react components permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rendering React Components</h2>\n<p>In other words, this is calling the <code class=\"language-text\">render()</code> method of the component.</p>\n<p>Although it might seem confusing at first glance, it’s actually super simple and straightforward. There is one simple rule: when you call <code class=\"language-text\">setState</code> in a component, that component and all of its children are marked as dirty. That means <code class=\"language-text\">render()</code> method will be called for each of these dirty components. While doing this, React does not even check whether props/state is actually changed, it just marks them as dirty blindly.</p>\n<p>When you call <code class=\"language-text\">setState()</code> in component B, <code class=\"language-text\">render()</code> will be called for B, D, E, and H.</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/7f1c78c10e99f317cbc09e189849bed7/1407e/cover.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 960px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 28.82154882154882%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAGABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3gUH/8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQABBQJ//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAEP/aAAgBAQAGPwJ//8QAFxAAAwEAAAAAAAAAAAAAAAAAABAxQf/aAAgBAQABPyEmr//aAAwDAQACAAMAAAAQgA//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxAn/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGBABAQEBAQAAAAAAAAAAAAAAAREAUUH/2gAIAQEAAT8QB7kYKa+6PTf/2Q=='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"cover\"\n        title=\"\"\n        src=\"/static/7f1c78c10e99f317cbc09e189849bed7/b3ee8/cover.jpg\"\n        srcset=\"/static/7f1c78c10e99f317cbc09e189849bed7/3bc27/cover.jpg 240w,\n/static/7f1c78c10e99f317cbc09e189849bed7/98431/cover.jpg 480w,\n/static/7f1c78c10e99f317cbc09e189849bed7/b3ee8/cover.jpg 960w,\n/static/7f1c78c10e99f317cbc09e189849bed7/b97fe/cover.jpg 1440w,\n/static/7f1c78c10e99f317cbc09e189849bed7/1407e/cover.jpg 1485w\"\n        sizes=\"(max-width: 960px) 100vw, 960px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>Let’s see it in action.\nIn this example, we’re calling <code class=\"language-text\">setState</code> on the Parent. It will mark the Parent and Child component as dirty. So, every second, both Parent and Child will get re-rendered. Please note, we’re not even changing the value of <code class=\"language-text\">unusedField</code> , it’s still <code class=\"language-text\">1</code>, but React re-renders everything regardless.</p>\n<div class=\"embed-container\">\n  <iframe width=\"100%\" height=\"400\" src=\"//jsfiddle.net/merictaze/3ow61faq/embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n</div>\n<p>When we move <code class=\"language-text\">setState</code> to the Child component, only child will get re-rendered every second while Parent is rendered only once.</p>\n<div class=\"embed-container\">\n  <iframe width=\"100%\" height=\"400\" src=\"//jsfiddle.net/merictaze/ko2La8jg/embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n</div>\n<p>Some of you might be asking “<em>OK, when state changes, component and its children re-renders, but what about props?</em>”. Let’s say component has <code class=\"language-text\">props.firstName</code>. Since it’s a prop, it means it is passed by its parent (parent can also be a HOC such as redux’s <code class=\"language-text\">connect()</code>). If you keep following <code class=\"language-text\">firstName</code> prop, it will eventually be defined as a <code class=\"language-text\">state</code> variable in one of the ancestors. If <code class=\"language-text\">state.firstName</code> is changed using <code class=\"language-text\">setState()</code>, it will trigger a re-render for that ancestor and all of its children. That means all the components which have <code class=\"language-text\">state.firstName</code> and  <code class=\"language-text\">props.firstName</code> also get re-rendered. So, all components will be showing the latest value for <code class=\"language-text\">firstName</code>. That’s why React only cares about <code class=\"language-text\">state</code> not <code class=\"language-text\">props</code> while deciding on whether to render a component. </p>\n<p>That’s it about default component rendering. Easy peasy! This simple logic will work great for most of the applications. If you have a complex application, you might need to fine-tune this behavior. Now, let’s see some ways of doing that.</p>\n<h3 id=\"using-shouldcomponentupdate\" style=\"position:relative;\"><a href=\"#using-shouldcomponentupdate\" aria-label=\"using shouldcomponentupdate permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Using shouldComponentUpdate</h3>\n<p>When react marks a component as dirty due to <code class=\"language-text\">setState()</code> call, it calls this method to decide whether to re-render the component and its children. By default, this method returns <code class=\"language-text\">true</code> . That’s why they are all re-rendered on every <code class=\"language-text\">setState()</code> call. You can override this method and tell React when you want your components to get re-rendered, and when it’s safe to skip.</p>\n<p>In below example, since we know <code class=\"language-text\">unusedField</code> is not needed in our component, we can ignore it. Also instead of re-rendering the component on every <code class=\"language-text\">setState</code> call, we can tell to re-render only when the actual value of <code class=\"language-text\">usedField</code> changes.</p>\n<p>Although we call <code class=\"language-text\">setState()</code> every second for two fields, nothing will be re-rendered as <code class=\"language-text\">state.unusedField</code> is not used in <code class=\"language-text\">shouldComponentUpdate()</code> and <code class=\"language-text\">state.usedField</code> is always <code class=\"language-text\">1</code>. So, <code class=\"language-text\">shouldComponentUpdate</code> will return false.</p>\n<div class=\"embed-container\">\n  <iframe width=\"100%\" height=\"400\" src=\"//jsfiddle.net/merictaze/ynpLavwt//embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n</div>\n<p>When we actually change the value of <code class=\"language-text\">state.usedField</code>, both Parent and Child will get re-rendered every second since <code class=\"language-text\">componentShouldUpdate</code> will return true.</p>\n<div class=\"embed-container\">\n  <iframe width=\"100%\" height=\"400\" src=\"//jsfiddle.net/merictaze/efuxgms4/embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n</div>\n<p>It’s suggested not to use <code class=\"language-text\">shouldComponentUpdate()</code> unless you really know what you’re doing and need to optimize the component really bad. It’s because in real world, your component will not be as simple as the one above. You’ll have tons of props/state with complex JSON and it will get hard to keep <code class=\"language-text\">shouldComponentUpdate</code> up-to-date. If you add a new prop and forget to add in the method, your component will not re-render and good luck debugging it. </p>\n<p>Another case might be you only care about some nested fields in a prop. Say you have a prop like this</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">order<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n  orderId<span class=\"token punctuation\">:</span> <span class=\"token string\">'12345'</span><span class=\"token punctuation\">,</span>\n  shippingDetails<span class=\"token punctuation\">:</span> <span class=\"token punctuation\">{</span>\n    deliveryDate<span class=\"token punctuation\">:</span> <span class=\"token string\">'2019-10-10 12:00'</span><span class=\"token punctuation\">,</span>\n    status<span class=\"token punctuation\">:</span> <span class=\"token string\">'IN TRANSIT'</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  customerName<span class=\"token punctuation\">:</span> <span class=\"token string\">'John Doe'</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>You only care about <code class=\"language-text\">props.order.shippingDetails.deliveryDate</code> and <code class=\"language-text\">props.order.orderId</code>. You can compare these two specific fields in your <code class=\"language-text\">shouldComponentUpdate</code> method.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">shouldComponentUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps<span class=\"token punctuation\">,</span> nextState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>order<span class=\"token punctuation\">.</span>orderId <span class=\"token operator\">!==</span> nextProps<span class=\"token punctuation\">.</span>order<span class=\"token punctuation\">.</span>orderId\n    <span class=\"token operator\">||</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>order<span class=\"token punctuation\">.</span>shippingDetails<span class=\"token punctuation\">.</span>deliveryDate <span class=\"token operator\">!==</span> nextProps<span class=\"token punctuation\">.</span>order<span class=\"token punctuation\">.</span>shippingDetails<span class=\"token punctuation\">.</span>deliveryDate<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>What if some developer decides to use <code class=\"language-text\">props.order.customerName</code> in the component and forgets to add this field to <code class=\"language-text\">shouldComponentUpdate</code> method? React will not re-render the component when <code class=\"language-text\">customerName</code> changes. One way to prevent this is using a deep equality check on <code class=\"language-text\">props.order</code> which will compare every single nested field in the object. (but, please don’t do this)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">shouldComponentUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps<span class=\"token punctuation\">,</span> nextState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token function\">deepEqual</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">.</span>order<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">.</span>order<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>If you don’t want to care even individual props, you can do something like below and your <code class=\"language-text\">shouldComponentUpdate</code> will always be up-to-date. (please don’t do this either)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">shouldComponentUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps<span class=\"token punctuation\">,</span> nextState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token function\">deepEqual</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">||</span> <span class=\"token operator\">!</span><span class=\"token function\">deepEqual</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>This might get super slow easily. At this point, you may realize the importance of immutable objects. If you create a new <code class=\"language-text\">order</code> object whenever <code class=\"language-text\">order.shippingDetails.deliveryDate</code> or any other field changes, you wouldn’t need to compare any sub-field. As long as the old and new references are the same (i.e. <code class=\"language-text\">this.props.order === nextProps.order</code>), you are sure nothing changed in this object. If they’re not the same, that means some field somewhere in <code class=\"language-text\">order</code> was changed, so no more <code class=\"language-text\">deepEqual</code>.</p>\n<p>So, with everything we learned so far, this seems like the best way to implement <code class=\"language-text\">shouldComponentUpdate()</code> as long as you don’t mutate sub-fields in your state. ( <code class=\"language-text\">shallowEqual</code> will compare top-level fields only like <code class=\"language-text\">this.props.field1 === nextProps.field1 &amp;&amp; this.props.field2 === nextProps.field2</code>)</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token function\">shouldComponentUpdate</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">nextProps<span class=\"token punctuation\">,</span> nextState</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token operator\">!</span><span class=\"token function\">shallowEqual</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>props<span class=\"token punctuation\">,</span> nextProps<span class=\"token punctuation\">)</span>\n    <span class=\"token operator\">||</span> <span class=\"token operator\">!</span><span class=\"token function\">shallowEqual</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>state<span class=\"token punctuation\">,</span> nextState<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Guess what? This is exactly what PureComponent does. That’s why it’s the suggested approach over using <code class=\"language-text\">shouldComponentUpdate()</code>. It’s safer, faster with one rule, that is making state fields immutable.</p>\n<h3 id=\"pure-components\" style=\"position:relative;\"><a href=\"#pure-components\" aria-label=\"pure components permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Pure Components</h3>\n<p>If you remember, default implementation for <code class=\"language-text\">shouldComponentUpdate</code> was returning true all the time. So, when you extend <code class=\"language-text\">React.Component</code> in your component, that’s what you get. But, you have another option, extending <code class=\"language-text\">React.PureComponent</code> to have a better implementation of <code class=\"language-text\">shouldComponentUpdate</code> as long as you promise you’ll keep it pure. And its implementation is exactly what we’ve seen in the previous part, shallow checks on <code class=\"language-text\">props</code> and <code class=\"language-text\">state</code>. Now let’s check some examples.</p>\n<p>First, let’s see the beauty of PureComponent. In the example below, we call <code class=\"language-text\">setState</code> every second, and update order object at random times.</p>\n<div class=\"embed-container\">\n  <iframe width=\"100%\" height=\"400\" src=\"//jsfiddle.net/merictaze/L80sjoxp/embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n</div>\n<p>As you’ve realized, render counter does not increase every second although you call <code class=\"language-text\">setState()</code> every second. It re-renders the components only when <code class=\"language-text\">order</code> object is changed.</p>\n<p>Now, let’s see what could go wrong if you don’t use PureComponent properly. Here, we’re going to update a field in <code class=\"language-text\">order</code> object in-place and call <code class=\"language-text\">setState</code> with that. If you were extending <code class=\"language-text\">React.Component</code>, it would just work since you call <code class=\"language-text\">setState()</code> and <code class=\"language-text\">shouldComponentUpdate()</code> always returns true. However, when you use <code class=\"language-text\">React.PureComponent</code>, shallow equality check in <code class=\"language-text\">shouldComponentUpdate</code> will return false since reference of <code class=\"language-text\">order</code> object hasn’t changed. So, no re-rendering and you won’t be able to see the latest value of the <code class=\"language-text\">customerName</code>.</p>\n<div class=\"embed-container\">\n  <iframe width=\"100%\" height=\"400\" src=\"//jsfiddle.net/merictaze/fcm8begw/embedded/js,result/\" allowfullscreen=\"allowfullscreen\" frameborder=\"0\"></iframe>\n</div>\n<h2 id=\"rendering-dom\" style=\"position:relative;\"><a href=\"#rendering-dom\" aria-label=\"rendering dom permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Rendering DOM</h2>\n<p>Every time you make a change in the actual DOM, it triggers a bunch of events and browser needs to do  some more stuff which is time-consuming. Because of that React came up with this idea of Virtual DOM. It’s a simplified JSON representation of the DOM. No events attached to elements and also browser does not care when you change it. It’s just the elements, their attributes and their children in a JSON object. It makes it cheap to make changes while rendering React components, and then React finds an efficient way of updating the actual DOM by diffing the old and new virtual DOMs.</p>\n<p>It’s an internal React logic and there is not much you can do about it. But, it’s good to know how it works so that you create your components in a way that it causes fewer DOM updates. However, the problem is that React can change the logic any time as it’s an internal implementation detail. So, better not to rely on anything on this part as it can change any time.</p>\n<p>More on how React updates the actual DOM can be found here <a href=\"https://reactjs.org/docs/reconciliation.html\">https://reactjs.org/docs/reconciliation.html</a></p>\n<h2 id=\"wrap-up\" style=\"position:relative;\"><a href=\"#wrap-up\" aria-label=\"wrap up permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Wrap up</h2>\n<p>Don’t go the route of premature optimization. Just go with the default behavior. When you realize re-rendering some components is really concerning and causing performance issues then try to optimize it by overriding <code class=\"language-text\">shouldComponentUpdate()</code>.</p>\n<p>If you’re confident of the purity of your components or using libraries like <code class=\"language-text\">immutable-js</code>, which ensures you won’t be able to make in-place updates to your <code class=\"language-text\">state</code>, then it’s better to go with <code class=\"language-text\">React.PureComponent</code> than implementing your own <code class=\"language-text\">shouldComponentUpdate()</code> as it gives less room for error and shallow equality check is cheap. </p>","headings":[{"value":"Rendering React Components","depth":2},{"value":"Using shouldComponentUpdate","depth":3},{"value":"Pure Components","depth":3},{"value":"Rendering DOM","depth":2},{"value":"Wrap up","depth":2}],"tableOfContents":"<ul>\n<li><a href=\"/posts/how-react-rendering-works-a-step-by-step-guide/#rendering-react-components\">Rendering React Components</a></li>\n<li><a href=\"/posts/how-react-rendering-works-a-step-by-step-guide/#rendering-dom\">Rendering DOM</a></li>\n<li><a href=\"/posts/how-react-rendering-works-a-step-by-step-guide/#wrap-up\">Wrap up</a></li>\n</ul>","fields":{"tagSlugs":["/tags/react/","/tags/render/","/tags/dom/","/tags/should-component-update/","/tags/pure-component/"],"slug":"/posts/how-react-rendering-works-a-step-by-step-guide/"},"frontmatter":{"title":"How React Rendering Works - A Step by Step Guide","tags":["react","render","DOM","shouldComponentUpdate","PureComponent"],"date":"2019-10-07","description":"Although what react is doing looks quite complex, underlying logic is very simple. And the easiest way to understand is just running some simple examples. We’ll dive into how react renders components and updates the actual DOM.","canonical":null}}},"pageContext":{"slug":"/posts/how-react-rendering-works-a-step-by-step-guide/"}},"staticQueryHashes":[]}